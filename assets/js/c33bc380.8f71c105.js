"use strict";(self.webpackChunkML_AI_LLM_notes=self.webpackChunkML_AI_LLM_notes||[]).push([[708],{392:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=i(4848),t=i(8453);const r={sidebar_position:5},a="Introduction to AI Decision Making Models",l={id:"amazon-ai/introduction-to-ai-decision-making-models",title:"Introduction to AI Decision Making Models",description:"AI and machine learning basics",source:"@site/docs/amazon-ai/introduction-to-ai-decision-making-models.md",sourceDirName:"amazon-ai",slug:"/amazon-ai/introduction-to-ai-decision-making-models",permalink:"/ML-AI-LLM-notes/docs/amazon-ai/introduction-to-ai-decision-making-models",draft:!1,unlisted:!1,editUrl:"https://github.com/devkobetran/ML-AI-LLM-notes/docs/amazon-ai/introduction-to-ai-decision-making-models.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"AI Software Design",permalink:"/ML-AI-LLM-notes/docs/amazon-ai/ai-software-design"},next:{title:"Digital Transformation",permalink:"/ML-AI-LLM-notes/docs/amazon-ai/digital-transformation"}},o={},d=[{value:"AI and machine learning basics",id:"ai-and-machine-learning-basics",level:2},{value:"Example: Creating a SPAM Filter",id:"example-creating-a-spam-filter",level:3},{value:"False Positives",id:"false-positives",level:4},{value:"No ML is perfect",id:"no-ml-is-perfect",level:4},{value:"Decision Trees",id:"decision-trees",level:2},{value:"Is reverse navigation in decision trees possible?",id:"is-reverse-navigation-in-decision-trees-possible",level:3},{value:"Binary Decision Trees",id:"binary-decision-trees",level:3},{value:"Multiway decision trees",id:"multiway-decision-trees",level:3},{value:"Continuous feature",id:"continuous-feature",level:3},{value:"Discretized feature",id:"discretized-feature",level:3},{value:"Pros &amp; Cons of Decision Trees",id:"pros--cons-of-decision-trees",level:3},{value:"Random Forests",id:"random-forests",level:2},{value:"Bagging",id:"bagging",level:3},{value:"Feature Randomness",id:"feature-randomness",level:3},{value:"Advantages",id:"advantages",level:3},{value:"Neural Networks",id:"neural-networks",level:2},{value:"Neural network in action",id:"neural-network-in-action",level:2},{value:"Input Layer",id:"input-layer",level:3},{value:"Hidden Layer",id:"hidden-layer",level:3},{value:"Output Layer",id:"output-layer",level:3},{value:"Scores, weights, and the activation function",id:"scores-weights-and-the-activation-function",level:3},{value:"Learning from mistakes: Error correction",id:"learning-from-mistakes-error-correction",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"introduction-to-ai-decision-making-models",children:"Introduction to AI Decision Making Models"})}),"\n",(0,s.jsx)(n.h2,{id:"ai-and-machine-learning-basics",children:"AI and machine learning basics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["AI:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Recognizes patterns"}),"\n",(0,s.jsx)(n.li,{children:"Understands language"}),"\n",(0,s.jsx)(n.li,{children:"Makes Decisions"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Machine Learning:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Learn from examples over time"}),"\n",(0,s.jsx)(n.li,{children:"Apply Learning to new tasks"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-creating-a-spam-filter",children:"Example: Creating a SPAM Filter"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Training Data","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Label the emails SPAM and Not SPAM"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Pre-process data","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clean: removes the irrelevant data or noise"}),"\n",(0,s.jsx)(n.li,{children:"Normalize: the data input is in a consistent structure and format, which is treated uniformly by the model"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Train the model","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Learn patterns from the training data"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Trained Spam Filter","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pattern to recognize Spam"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"false-positives",children:"False Positives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"An email is mistakenly classified as SPAM because it shares characteristics or patterns of a spam email."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"no-ml-is-perfect",children:"No ML is perfect"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Errors can occur"}),"\n",(0,s.jsx)(n.li,{children:"Requires people to critically evaluate the output"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision-trees",children:"Decision Trees"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Decision Trees"})," help classify data and predict outcomes by breaking down this decision-making process into series of simple questions."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"tree"})," is a data structure that organizes data hierarchically.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It consists of a series of points called nodes."}),"\n",(0,s.jsx)(n.li,{children:"The tree is upside of a natural tree."}),"\n",(0,s.jsx)(n.li,{children:"The root is at the top (root node, level 0)"}),"\n",(0,s.jsx)(n.li,{children:"The leaves at the bottom."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Child Nodes: connected below another node, like branches growing out"}),"\n",(0,s.jsx)(n.li,{children:"Parent node: A node that has child nodes below it"}),"\n",(0,s.jsx)(n.li,{children:"Leaf Nodes: nodes at the bottom of the tree with no children. These represent final decisions or outcomes."}),"\n",(0,s.jsx)(n.li,{children:"Internal Nodes: nodes that have at least one child node as well as a parent node. They are intermediate decision points in the tree"}),"\n",(0,s.jsx)(n.li,{children:"A Decision tree is a specialized type of tree in ML to make decisions based on input data."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input Data"}),": info or observations provided to the model so it can either learn during training or make decisions based on the rules it learned."]}),"\n",(0,s.jsx)(n.li,{children:"Decision Trees mimic how humans make decisions by splitting data at each node based on specific conditions."}),"\n",(0,s.jsxs)(n.li,{children:["In a decision tree:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Internal nodes: Represent questions or conditions."}),"\n",(0,s.jsx)(n.li,{children:"Branches: Represent possible answers or outcomes of a condition."}),"\n",(0,s.jsx)(n.li,{children:"Leaf nodes: Represent the final decision or result."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Features"}),": characteristics under consideration","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Their values are called ",(0,s.jsx)(n.strong,{children:"Feature Values"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"The goal of a decision tree is to split data into subsets based on feature values until a clear decision can be made."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Subsets"})," are smaller groups of data created by dividing the original dataset according to specific conditions."]}),"\n",(0,s.jsxs)(n.li,{children:["In Summary, Decision Trees:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Purpose: Facilitates decision-making by asking a series of step-by-step questions"}),"\n",(0,s.jsx)(n.li,{children:"Nodes: Represents questions in nodes and answers at the endpoints (leaves)."}),"\n",(0,s.jsx)(n.li,{children:'Structure: Uses a sequence of "yes" or "no" questions to follow a path and reach a decision.'}),"\n",(0,s.jsx)(n.li,{children:"Example: Predicts outcomes, like determining if a student will pass or fail based on study hours and attendance."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"In Contrast, a general tree, think of files and folders in a computer as an example."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"is-reverse-navigation-in-decision-trees-possible",children:"Is reverse navigation in decision trees possible?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Backtracking or navigating backward is not possible in a decision tree."}),"\n",(0,s.jsx)(n.li,{children:"Once a decision tree splits the data and makes a decision at a node, it continues forward along a specific path."}),"\n",(0,s.jsx)(n.li,{children:"It cannot reverse the decision or return to revisit previous nodes."}),"\n",(0,s.jsxs)(n.li,{children:["The direction can only be from the root towards the leaf and never be reversed, which means it\u2019s ",(0,s.jsx)(n.strong,{children:"unidirectional"}),", moving from the root to a leaf node."]}),"\n",(0,s.jsxs)(n.li,{children:["Unidirectional navigation offers the following advantages:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Every path leads to a leaf node"}),"\n",(0,s.jsx)(n.li,{children:"Handling all possible outcomes:"}),"\n",(0,s.jsx)(n.li,{children:"Exhaustive conditions: account for all possible values of a feature at each split."}),"\n",(0,s.jsx)(n.li,{children:"Default behavior: If a decision tree encounters data outside the scope of its training data, it still tries to follow the closest matching path to reach a leaf node, though the result may not be as accurate."}),"\n",(0,s.jsx)(n.li,{children:"No infinite loops"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"binary-decision-trees",children:"Binary Decision Trees"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maximum of two child nodes"}),"\n",(0,s.jsx)(n.li,{children:'Each decision splits the data into two subsets based on a binary condition (e.g., "Yes" or "No").'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"multiway-decision-trees",children:"Multiway decision trees"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A multiway decision tree is characterized by ",(0,s.jsx)(n.code,{children:"k"})," child nodes, where ",(0,s.jsx)(n.code,{children:"k"})," is the number of unique values in a categorical feature.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'For example, for a feature like "Weather" with possible values of \u201cSunny,\u201d \u201cRainy,\u201d or \u201cCloudy,\u201d each node can have up to three child nodes; that is, one for each unique value.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"continuous-feature",children:"Continuous feature"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When a feature or characteristic can take any value in a range"}),"\n",(0,s.jsx)(n.li,{children:"For example, a person\u2019s age can be any value in the range of 1 to 100."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"discretized-feature",children:"Discretized feature"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If a continuous feature or characteristic is split into categories, it is known to be discretized."}),"\n",(0,s.jsxs)(n.li,{children:["For example:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Child: Age from 1 to 18 years"}),"\n",(0,s.jsx)(n.li,{children:"Young adult: Age from 19 to 35 years"}),"\n",(0,s.jsx)(n.li,{children:"Adult: Age from 36 to 80 years"}),"\n",(0,s.jsx)(n.li,{children:"Seniors: Age above 80 years"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"pros--cons-of-decision-trees",children:"Pros & Cons of Decision Trees"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Advantages:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Easy to understand"}),"\n",(0,s.jsx)(n.li,{children:"Works with different data such as numerical and categorical data"}),"\n",(0,s.jsx)(n.li,{children:"Non-parametric: They don\u2019t assume a specific distribution of data, where data may not follow standard distributions."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Disavantages:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Overfitting: Decision trees can become overly complex, capturing noise in the data rather than the underlying pattern.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Noise refers to patterns that are not meaningful to the decision-making process but can influence it."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Instability: A slight change in the data can lead to a completely different tree structure."}),"\n",(0,s.jsx)(n.li,{children:"Bias towards features with more levels: Decision trees can be biased toward features with many unique values."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"random-forests",children:"Random Forests"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Random Forests:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Group of Decision Trees"}),"\n",(0,s.jsx)(n.li,{children:"Combined Results"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Overfitting: failing to generalize to new data"}),"\n",(0,s.jsx)(n.li,{children:"Random Forests overcome the issue of overfitting."}),"\n",(0,s.jsx)(n.li,{children:"The final result is the average output."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"bagging",children:"Bagging"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Bagging (Bootstrap Aggregating): the technique of each tree in a random forest being trained on a different random subset, characteristic, or feature of the data","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces the chances of overfitting by ensuring that each tree has a unique perspective on the data"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"feature-randomness",children:"Feature Randomness"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Feature Randomness"}),": at each split in a tree, only a random subset of the features is considered.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adds a layer of randomness, ensuring that the trees don't all appear the same and rely too heavily on specific features."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduced overfitting"}),"\n",(0,s.jsx)(n.li,{children:"Improved accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Versatility"}),"\n",(0,s.jsx)(n.li,{children:"Handle Missing Data"}),"\n",(0,s.jsx)(n.li,{children:"Numerical & Categorical Features"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"neural-networks",children:"Neural Networks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"Neural Network"})," is a computation model inspired by the human brain"]}),"\n",(0,s.jsxs)(n.li,{children:["3 main steps:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Input layer: starting point to pass raw data like an image"}),"\n",(0,s.jsx)(n.li,{children:"Hidden layers: data passes through the input layer to intermediate stations, where the data is processed and transformed."}),"\n",(0,s.jsx)(n.li,{children:"Output layers: the network produces the result"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Each layer consists of ",(0,s.jsx)(n.strong,{children:"neurons (nodes)"}),", which are interconnected and work together to process the input"]}),"\n",(0,s.jsx)(n.li,{children:"A neuron is the smallest computational unit in a neural network"}),"\n",(0,s.jsx)(n.li,{children:"Neurons mimics biological neurons in the brain"}),"\n",(0,s.jsx)(n.li,{children:"A neuron receives input from either the input layer or previous neurons and processes them and makes decisions on whether it should be sent forward to the next layer or not."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"neural-network-in-action",children:"Neural network in action"}),"\n",(0,s.jsx)(n.p,{children:"This example we are sorting fruits into categories (color, size, and shape)."}),"\n",(0,s.jsx)(n.h3,{id:"input-layer",children:"Input Layer"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The input layer is where the raw features are fed into the network."}),"\n",(0,s.jsxs)(n.li,{children:["Input features:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Color: Red or Not Red"}),"\n",(0,s.jsx)(n.li,{children:"Size: Small or Medium"}),"\n",(0,s.jsx)(n.li,{children:"Shape: Is it like an apple or not?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"hidden-layer",children:"Hidden Layer"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The hidden layers are where the network starts processing the inputs to find patterns."}),"\n",(0,s.jsxs)(n.li,{children:["Each neuron in the hidden layer combines the inputs, applies values known as weights (signifying the importance) to each input, and then uses an activation function to decide whether to pass the information forward.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"weights help the network prioritize certain features over others when making its decision."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"In this example, one neuron can check for color, another checks for size, and the last neuron checks for shape."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"output-layer",children:"Output Layer"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The output layer takes the combined information and produces the final prediction."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scores-weights-and-the-activation-function",children:"Scores, weights, and the activation function"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Scoring the outputs from the hidden layer: Each neuron outputs a score or signal, which represents the likelihood of a particular feature matching the target. These scores will then be combined to make a prediction."}),"\n",(0,s.jsx)(n.li,{children:"Assigning the weighted scores: Each hidden layer output is assigned a value called a weight based on its importance."}),"\n",(0,s.jsx)(n.li,{children:'Summing the weighted scores: this will produce the combined score from the hidden layer. This weighted summation gives the final "confidence score" for the prediction.'}),"\n",(0,s.jsx)(n.li,{children:"Passing through the activation function: the data is passed from the hidden layer to the output layer. In the output layer, the combined score is passed through an activation function."}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For example, an example of an activation function that produces a result between 0 and 1 is Sigmoid."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Sigmoid = 1 / ( 1 + e^(-x) )\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"There are other functions beyond that like ReLU (Rectified Linear Unit), Tanh (Hyperbolic Tangent), ELU (Exponential Linear Unit), Softmax, Swish"}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsx)(n.li,{children:"Making a final decision in the output layer: The output layer uses the activation results to make the final decision."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"learning-from-mistakes-error-correction",children:"Learning from mistakes: Error correction"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A neural network learns by checking its mistakes and its weights, like a feedback loop, and trying again with the adjusted weight for the different features."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);